"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/SplashCursor.tsx":
/*!*****************************************!*\
  !*** ./src/components/SplashCursor.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SplashCursor)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction pointerPrototype() {\n    return {\n        id: -1,\n        texcoordX: 0,\n        texcoordY: 0,\n        prevTexcoordX: 0,\n        prevTexcoordY: 0,\n        deltaX: 0,\n        deltaY: 0,\n        down: false,\n        moved: false,\n        color: {\n            r: 255,\n            g: 220,\n            b: 180\n        } // Light warm color\n    };\n}\nfunction SplashCursor(param) {\n    let { SIM_RESOLUTION = 64, DYE_RESOLUTION = 256, DENSITY_DISSIPATION = 0.95, VELOCITY_DISSIPATION = 0.4, PRESSURE = 0.5, PRESSURE_ITERATIONS = 8, CURL = 10, SPLAT_RADIUS = 0.12, SPLAT_FORCE = 2000, SHADING = false, COLOR_UPDATE_SPEED = 20, BACK_COLOR = {\n        r: 0,\n        g: 0,\n        b: 0\n    }, TRANSPARENT = true } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SplashCursor.useEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            let animationId;\n            let gl = null;\n            // Simple WebGL setup\n            try {\n                gl = canvas.getContext('webgl2') || canvas.getContext('webgl');\n                if (!gl) return;\n            } catch (e) {\n                return;\n            }\n            const pointer = pointerPrototype();\n            let lastTime = 0;\n            let colorTimer = 0;\n            // Light, appealing colors that don't interfere with forms\n            const lightColors = [\n                {\n                    r: 255,\n                    g: 230,\n                    b: 200\n                },\n                {\n                    r: 230,\n                    g: 255,\n                    b: 220\n                },\n                {\n                    r: 220,\n                    g: 240,\n                    b: 255\n                },\n                {\n                    r: 255,\n                    g: 220,\n                    b: 240\n                },\n                {\n                    r: 250,\n                    g: 255,\n                    b: 220\n                },\n                {\n                    r: 240,\n                    g: 220,\n                    b: 255\n                }\n            ];\n            function generateColor() {\n                const randomColor = lightColors[Math.floor(Math.random() * lightColors.length)];\n                return {\n                    r: randomColor.r * 0.4,\n                    g: randomColor.g * 0.4,\n                    b: randomColor.b * 0.4\n                };\n            }\n            function resizeCanvas() {\n                const displayWidth = canvas.clientWidth;\n                const displayHeight = canvas.clientHeight;\n                if (canvas.width !== displayWidth || canvas.height !== displayHeight) {\n                    canvas.width = displayWidth;\n                    canvas.height = displayHeight;\n                    if (gl) {\n                        gl.viewport(0, 0, displayWidth, displayHeight);\n                    }\n                    return true;\n                }\n                return false;\n            }\n            function updatePointer(x, y) {\n                const rect = canvas.getBoundingClientRect();\n                pointer.prevTexcoordX = pointer.texcoordX;\n                pointer.prevTexcoordY = pointer.texcoordY;\n                pointer.texcoordX = (x - rect.left) / rect.width;\n                pointer.texcoordY = 1 - (y - rect.top) / rect.height;\n                pointer.deltaX = pointer.texcoordX - pointer.prevTexcoordX;\n                pointer.deltaY = pointer.texcoordY - pointer.prevTexcoordY;\n                pointer.moved = Math.abs(pointer.deltaX) > 0.001 || Math.abs(pointer.deltaY) > 0.001;\n            }\n            function render(currentTime) {\n                const dt = Math.min((currentTime - lastTime) / 1000, 0.016); // Cap at 60fps\n                lastTime = currentTime;\n                resizeCanvas();\n                if (!gl) return;\n                // Update colors periodically\n                colorTimer += dt * COLOR_UPDATE_SPEED;\n                if (colorTimer >= 1) {\n                    colorTimer = 0;\n                    pointer.color = generateColor();\n                }\n                // Simple gradient background with subtle animation\n                gl.clearColor(0, 0, 0, 0);\n                gl.clear(gl.COLOR_BUFFER_BIT);\n                // Create a simple animated gradient effect\n                if (pointer.moved) {\n                    const intensity = Math.min(Math.sqrt(pointer.deltaX * pointer.deltaX + pointer.deltaY * pointer.deltaY) * 10, 1);\n                    // Simple radial gradient effect\n                    const gradient = gl.createRadialGradient ? gl.createRadialGradient(pointer.texcoordX * canvas.width, pointer.texcoordY * canvas.height, 0, pointer.texcoordX * canvas.width, pointer.texcoordY * canvas.height, SPLAT_RADIUS * Math.min(canvas.width, canvas.height)) : null;\n                    if (gradient) {\n                        gradient.addColorStop(0, \"rgba(\".concat(pointer.color.r, \", \").concat(pointer.color.g, \", \").concat(pointer.color.b, \", \").concat(intensity * 0.3, \")\"));\n                        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n                    }\n                    pointer.moved = false;\n                }\n                animationId = requestAnimationFrame(render);\n            }\n            // Event listeners\n            const handleMouseMove = {\n                \"SplashCursor.useEffect.handleMouseMove\": (e)=>{\n                    updatePointer(e.clientX, e.clientY);\n                }\n            }[\"SplashCursor.useEffect.handleMouseMove\"];\n            const handleTouchMove = {\n                \"SplashCursor.useEffect.handleTouchMove\": (e)=>{\n                    e.preventDefault();\n                    if (e.touches.length > 0) {\n                        updatePointer(e.touches[0].clientX, e.touches[0].clientY);\n                    }\n                }\n            }[\"SplashCursor.useEffect.handleTouchMove\"];\n            // Add event listeners\n            window.addEventListener('mousemove', handleMouseMove, {\n                passive: true\n            });\n            window.addEventListener('touchmove', handleTouchMove, {\n                passive: false\n            });\n            // Initialize\n            resizeCanvas();\n            pointer.color = generateColor();\n            animationId = requestAnimationFrame(render);\n            // Cleanup\n            return ({\n                \"SplashCursor.useEffect\": ()=>{\n                    if (animationId) {\n                        cancelAnimationFrame(animationId);\n                    }\n                    window.removeEventListener('mousemove', handleMouseMove);\n                    window.removeEventListener('touchmove', handleTouchMove);\n                }\n            })[\"SplashCursor.useEffect\"];\n        }\n    }[\"SplashCursor.useEffect\"], [\n        SIM_RESOLUTION,\n        DYE_RESOLUTION,\n        DENSITY_DISSIPATION,\n        VELOCITY_DISSIPATION,\n        PRESSURE,\n        PRESSURE_ITERATIONS,\n        CURL,\n        SPLAT_RADIUS,\n        SPLAT_FORCE,\n        SHADING,\n        COLOR_UPDATE_SPEED,\n        BACK_COLOR,\n        TRANSPARENT\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"fixed top-0 left-0 z-10 pointer-events-none w-full h-full opacity-40\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n            ref: canvasRef,\n            id: \"fluid\",\n            className: \"w-full h-full block\",\n            style: {\n                background: 'transparent',\n                mixBlendMode: 'multiply' // Blend mode to avoid interference with forms\n            }\n        }, void 0, false, {\n            fileName: \"E:\\\\IYFDelhi-Braj\\\\iskon-youth-forum\\\\src\\\\components\\\\SplashCursor.tsx\",\n            lineNumber: 228,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"E:\\\\IYFDelhi-Braj\\\\iskon-youth-forum\\\\src\\\\components\\\\SplashCursor.tsx\",\n        lineNumber: 227,\n        columnNumber: 5\n    }, this);\n}\n_s(SplashCursor, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = SplashCursor;\nvar _c;\n$RefreshReg$(_c, \"SplashCursor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1NwbGFzaEN1cnNvci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRWlEO0FBcUNqRCxTQUFTRztJQUNQLE9BQU87UUFDTEMsSUFBSSxDQUFDO1FBQ0xDLFdBQVc7UUFDWEMsV0FBVztRQUNYQyxlQUFlO1FBQ2ZDLGVBQWU7UUFDZkMsUUFBUTtRQUNSQyxRQUFRO1FBQ1JDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxPQUFPO1lBQUVDLEdBQUc7WUFBS0MsR0FBRztZQUFLQyxHQUFHO1FBQUksRUFBRSxtQkFBbUI7SUFDdkQ7QUFDRjtBQUVlLFNBQVNDLGFBQWEsS0FjakI7UUFkaUIsRUFDbkNDLGlCQUFpQixFQUFFLEVBQ25CQyxpQkFBaUIsR0FBRyxFQUNwQkMsc0JBQXNCLElBQUksRUFDMUJDLHVCQUF1QixHQUFHLEVBQzFCQyxXQUFXLEdBQUcsRUFDZEMsc0JBQXNCLENBQUMsRUFDdkJDLE9BQU8sRUFBRSxFQUNUQyxlQUFlLElBQUksRUFDbkJDLGNBQWMsSUFBSSxFQUNsQkMsVUFBVSxLQUFLLEVBQ2ZDLHFCQUFxQixFQUFFLEVBQ3ZCQyxhQUFhO1FBQUVmLEdBQUc7UUFBR0MsR0FBRztRQUFHQyxHQUFHO0lBQUUsQ0FBQyxFQUNqQ2MsY0FBYyxJQUFJLEVBQ0EsR0FkaUI7O0lBZW5DLE1BQU1DLFlBQVk5Qiw2Q0FBTUEsQ0FBb0I7SUFFNUNDLGdEQUFTQTtrQ0FBQztZQUNSLE1BQU04QixTQUFTRCxVQUFVRSxPQUFPO1lBQ2hDLElBQUksQ0FBQ0QsUUFBUTtZQUViLElBQUlFO1lBQ0osSUFBSUMsS0FBNEQ7WUFFaEUscUJBQXFCO1lBQ3JCLElBQUk7Z0JBQ0ZBLEtBQUtILE9BQU9JLFVBQVUsQ0FBQyxhQUFhSixPQUFPSSxVQUFVLENBQUM7Z0JBQ3RELElBQUksQ0FBQ0QsSUFBSTtZQUNYLEVBQUUsT0FBT0UsR0FBRztnQkFDVjtZQUNGO1lBRUEsTUFBTUMsVUFBVW5DO1lBQ2hCLElBQUlv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RUFBRTZDLE9BQU8sQ0FBQyxFQUFFLENBQUNKLE9BQU8sRUFBRXpDLEVBQUU2QyxPQUFPLENBQUMsRUFBRSxDQUFDSCxPQUFPO29CQUMxRDtnQkFDRjs7WUFFQSxzQkFBc0I7WUFDdEJJLE9BQU9DLGdCQUFnQixDQUFDLGFBQWFQLGlCQUFpQjtnQkFBRVEsU0FBUztZQUFLO1lBQ3RFRixPQUFPQyxnQkFBZ0IsQ0FBQyxhQUFhSixpQkFBaUI7Z0JBQUVLLFNBQVM7WUFBTTtZQUV2RSxhQUFhO1lBQ2JyQztZQUNBVixRQUFRekIsS0FBSyxHQUFHNkI7WUFDaEJSLGNBQWMwQyxzQkFBc0JaO1lBRXBDLFVBQVU7WUFDVjswQ0FBTztvQkFDTCxJQUFJOUIsYUFBYTt3QkFDZm9ELHFCQUFxQnBEO29CQUN2QjtvQkFDQWlELE9BQU9JLG1CQUFtQixDQUFDLGFBQWFWO29CQUN4Q00sT0FBT0ksbUJBQW1CLENBQUMsYUFBYVA7Z0JBQzFDOztRQUNGO2lDQUFHO1FBQ0Q5RDtRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztLQUNEO0lBRUQscUJBQ0UsOERBQUMwRDtRQUFJQyxXQUFVO2tCQUNiLDRFQUFDekQ7WUFDQzBELEtBQUszRDtZQUNMM0IsSUFBRztZQUNIcUYsV0FBVTtZQUNWRSxPQUFPO2dCQUNMQyxZQUFZO2dCQUNaQyxjQUFjLFdBQVcsOENBQThDO1lBQ3pFOzs7Ozs7Ozs7OztBQUlSO0dBeEx3QjVFO0tBQUFBIiwic291cmNlcyI6WyJFOlxcSVlGRGVsaGktQnJhalxcaXNrb24teW91dGgtZm9ydW1cXHNyY1xcY29tcG9uZW50c1xcU3BsYXNoQ3Vyc29yLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5pbnRlcmZhY2UgQ29sb3JSR0Ige1xyXG4gIHI6IG51bWJlcjtcclxuICBnOiBudW1iZXI7XHJcbiAgYjogbnVtYmVyO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU3BsYXNoQ3Vyc29yUHJvcHMge1xyXG4gIFNJTV9SRVNPTFVUSU9OPzogbnVtYmVyO1xyXG4gIERZRV9SRVNPTFVUSU9OPzogbnVtYmVyO1xyXG4gIERFTlNJVFlfRElTU0lQQVRJT04/OiBudW1iZXI7XHJcbiAgVkVMT0NJVFlfRElTU0lQQVRJT04/OiBudW1iZXI7XHJcbiAgUFJFU1NVUkU/OiBudW1iZXI7XHJcbiAgUFJFU1NVUkVfSVRFUkFUSU9OUz86IG51bWJlcjtcclxuICBDVVJMPzogbnVtYmVyO1xyXG4gIFNQTEFUX1JBRElVUz86IG51bWJlcjtcclxuICBTUExBVF9GT1JDRT86IG51bWJlcjtcclxuICBTSEFESU5HPzogYm9vbGVhbjtcclxuICBDT0xPUl9VUERBVEVfU1BFRUQ/OiBudW1iZXI7XHJcbiAgQkFDS19DT0xPUj86IENvbG9yUkdCO1xyXG4gIFRSQU5TUEFSRU5UPzogYm9vbGVhbjtcclxufVxyXG5cclxuaW50ZXJmYWNlIFBvaW50ZXIge1xyXG4gIGlkOiBudW1iZXI7XHJcbiAgdGV4Y29vcmRYOiBudW1iZXI7XHJcbiAgdGV4Y29vcmRZOiBudW1iZXI7XHJcbiAgcHJldlRleGNvb3JkWDogbnVtYmVyO1xyXG4gIHByZXZUZXhjb29yZFk6IG51bWJlcjtcclxuICBkZWx0YVg6IG51bWJlcjtcclxuICBkZWx0YVk6IG51bWJlcjtcclxuICBkb3duOiBib29sZWFuO1xyXG4gIG1vdmVkOiBib29sZWFuO1xyXG4gIGNvbG9yOiBDb2xvclJHQjtcclxufVxyXG5cclxuZnVuY3Rpb24gcG9pbnRlclByb3RvdHlwZSgpOiBQb2ludGVyIHtcclxuICByZXR1cm4ge1xyXG4gICAgaWQ6IC0xLFxyXG4gICAgdGV4Y29vcmRYOiAwLFxyXG4gICAgdGV4Y29vcmRZOiAwLFxyXG4gICAgcHJldlRleGNvb3JkWDogMCxcclxuICAgIHByZXZUZXhjb29yZFk6IDAsXHJcbiAgICBkZWx0YVg6IDAsXHJcbiAgICBkZWx0YVk6IDAsXHJcbiAgICBkb3duOiBmYWxzZSxcclxuICAgIG1vdmVkOiBmYWxzZSxcclxuICAgIGNvbG9yOiB7IHI6IDI1NSwgZzogMjIwLCBiOiAxODAgfSAvLyBMaWdodCB3YXJtIGNvbG9yXHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3BsYXNoQ3Vyc29yKHtcclxuICBTSU1fUkVTT0xVVElPTiA9IDY0LCAvLyBSZWR1Y2VkIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcclxuICBEWUVfUkVTT0xVVElPTiA9IDI1NiwgLy8gUmVkdWNlZCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXHJcbiAgREVOU0lUWV9ESVNTSVBBVElPTiA9IDAuOTUsIC8vIEZhc3RlciBkaXNzaXBhdGlvblxyXG4gIFZFTE9DSVRZX0RJU1NJUEFUSU9OID0gMC40LCAvLyBGYXN0ZXIgZGlzc2lwYXRpb25cclxuICBQUkVTU1VSRSA9IDAuNSwgLy8gUmVkdWNlZCBwcmVzc3VyZVxyXG4gIFBSRVNTVVJFX0lURVJBVElPTlMgPSA4LCAvLyBSZWR1Y2VkIGl0ZXJhdGlvbnMgZm9yIHBlcmZvcm1hbmNlXHJcbiAgQ1VSTCA9IDEwLCAvLyBSZWR1Y2VkIGN1cmxcclxuICBTUExBVF9SQURJVVMgPSAwLjEyLCAvLyBTbWFsbGVyIHJhZGl1c1xyXG4gIFNQTEFUX0ZPUkNFID0gMjAwMCwgLy8gUmVkdWNlZCBmb3JjZVxyXG4gIFNIQURJTkcgPSBmYWxzZSwgLy8gRGlzYWJsZWQgZm9yIHBlcmZvcm1hbmNlXHJcbiAgQ09MT1JfVVBEQVRFX1NQRUVEID0gMjAsIC8vIEZhc3RlciBjb2xvciB1cGRhdGVzXHJcbiAgQkFDS19DT0xPUiA9IHsgcjogMCwgZzogMCwgYjogMCB9LFxyXG4gIFRSQU5TUEFSRU5UID0gdHJ1ZVxyXG59OiBTcGxhc2hDdXJzb3JQcm9wcykge1xyXG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgIGlmICghY2FudmFzKSByZXR1cm47XHJcblxyXG4gICAgbGV0IGFuaW1hdGlvbklkOiBudW1iZXI7XHJcbiAgICBsZXQgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgfCBXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBudWxsID0gbnVsbDtcclxuICAgIFxyXG4gICAgLy8gU2ltcGxlIFdlYkdMIHNldHVwXHJcbiAgICB0cnkge1xyXG4gICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKTtcclxuICAgICAgaWYgKCFnbCkgcmV0dXJuO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJQcm90b3R5cGUoKTtcclxuICAgIGxldCBsYXN0VGltZSA9IDA7XHJcbiAgICBsZXQgY29sb3JUaW1lciA9IDA7XHJcblxyXG4gICAgLy8gTGlnaHQsIGFwcGVhbGluZyBjb2xvcnMgdGhhdCBkb24ndCBpbnRlcmZlcmUgd2l0aCBmb3Jtc1xyXG4gICAgY29uc3QgbGlnaHRDb2xvcnMgPSBbXHJcbiAgICAgIHsgcjogMjU1LCBnOiAyMzAsIGI6IDIwMCB9LCAvLyBMaWdodCBwZWFjaFxyXG4gICAgICB7IHI6IDIzMCwgZzogMjU1LCBiOiAyMjAgfSwgLy8gTGlnaHQgbWludFxyXG4gICAgICB7IHI6IDIyMCwgZzogMjQwLCBiOiAyNTUgfSwgLy8gTGlnaHQgc2t5IGJsdWVcclxuICAgICAgeyByOiAyNTUsIGc6IDIyMCwgYjogMjQwIH0sIC8vIExpZ2h0IHBpbmtcclxuICAgICAgeyByOiAyNTAsIGc6IDI1NSwgYjogMjIwIH0sIC8vIExpZ2h0IHllbGxvdy1ncmVlblxyXG4gICAgICB7IHI6IDI0MCwgZzogMjIwLCBiOiAyNTUgfSwgLy8gTGlnaHQgbGF2ZW5kZXJcclxuICAgIF07XHJcblxyXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDb2xvcigpOiBDb2xvclJHQiB7XHJcbiAgICAgIGNvbnN0IHJhbmRvbUNvbG9yID0gbGlnaHRDb2xvcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGlnaHRDb2xvcnMubGVuZ3RoKV07XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcjogcmFuZG9tQ29sb3IuciAqIDAuNCwgLy8gVmVyeSBzdWJ0bGVcclxuICAgICAgICBnOiByYW5kb21Db2xvci5nICogMC40LFxyXG4gICAgICAgIGI6IHJhbmRvbUNvbG9yLmIgKiAwLjRcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZXNpemVDYW52YXMoKSB7XHJcbiAgICAgIGNvbnN0IGRpc3BsYXlXaWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcclxuICAgICAgY29uc3QgZGlzcGxheUhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoY2FudmFzLndpZHRoICE9PSBkaXNwbGF5V2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gZGlzcGxheUhlaWdodCkge1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcclxuICAgICAgICBpZiAoZ2wpIHtcclxuICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIGRpc3BsYXlXaWR0aCwgZGlzcGxheUhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVQb2ludGVyKHg6IG51bWJlciwgeTogbnVtYmVyKSB7XHJcbiAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgIHBvaW50ZXIucHJldlRleGNvb3JkWCA9IHBvaW50ZXIudGV4Y29vcmRYO1xyXG4gICAgICBwb2ludGVyLnByZXZUZXhjb29yZFkgPSBwb2ludGVyLnRleGNvb3JkWTtcclxuICAgICAgcG9pbnRlci50ZXhjb29yZFggPSAoeCAtIHJlY3QubGVmdCkgLyByZWN0LndpZHRoO1xyXG4gICAgICBwb2ludGVyLnRleGNvb3JkWSA9IDEgLSAoeSAtIHJlY3QudG9wKSAvIHJlY3QuaGVpZ2h0O1xyXG4gICAgICBwb2ludGVyLmRlbHRhWCA9IHBvaW50ZXIudGV4Y29vcmRYIC0gcG9pbnRlci5wcmV2VGV4Y29vcmRYO1xyXG4gICAgICBwb2ludGVyLmRlbHRhWSA9IHBvaW50ZXIudGV4Y29vcmRZIC0gcG9pbnRlci5wcmV2VGV4Y29vcmRZO1xyXG4gICAgICBwb2ludGVyLm1vdmVkID0gTWF0aC5hYnMocG9pbnRlci5kZWx0YVgpID4gMC4wMDEgfHwgTWF0aC5hYnMocG9pbnRlci5kZWx0YVkpID4gMC4wMDE7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVuZGVyKGN1cnJlbnRUaW1lOiBudW1iZXIpIHtcclxuICAgICAgY29uc3QgZHQgPSBNYXRoLm1pbigoY3VycmVudFRpbWUgLSBsYXN0VGltZSkgLyAxMDAwLCAwLjAxNik7IC8vIENhcCBhdCA2MGZwc1xyXG4gICAgICBsYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xyXG5cclxuICAgICAgcmVzaXplQ2FudmFzKCk7XHJcblxyXG4gICAgICBpZiAoIWdsKSByZXR1cm47XHJcblxyXG4gICAgICAvLyBVcGRhdGUgY29sb3JzIHBlcmlvZGljYWxseVxyXG4gICAgICBjb2xvclRpbWVyICs9IGR0ICogQ09MT1JfVVBEQVRFX1NQRUVEO1xyXG4gICAgICBpZiAoY29sb3JUaW1lciA+PSAxKSB7XHJcbiAgICAgICAgY29sb3JUaW1lciA9IDA7XHJcbiAgICAgICAgcG9pbnRlci5jb2xvciA9IGdlbmVyYXRlQ29sb3IoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2ltcGxlIGdyYWRpZW50IGJhY2tncm91bmQgd2l0aCBzdWJ0bGUgYW5pbWF0aW9uXHJcbiAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XHJcbiAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIGEgc2ltcGxlIGFuaW1hdGVkIGdyYWRpZW50IGVmZmVjdFxyXG4gICAgICBpZiAocG9pbnRlci5tb3ZlZCkge1xyXG4gICAgICAgIGNvbnN0IGludGVuc2l0eSA9IE1hdGgubWluKE1hdGguc3FydChwb2ludGVyLmRlbHRhWCAqIHBvaW50ZXIuZGVsdGFYICsgcG9pbnRlci5kZWx0YVkgKiBwb2ludGVyLmRlbHRhWSkgKiAxMCwgMSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU2ltcGxlIHJhZGlhbCBncmFkaWVudCBlZmZlY3RcclxuICAgICAgICBjb25zdCBncmFkaWVudCA9IGdsLmNyZWF0ZVJhZGlhbEdyYWRpZW50ID8gXHJcbiAgICAgICAgICBnbC5jcmVhdGVSYWRpYWxHcmFkaWVudChcclxuICAgICAgICAgICAgcG9pbnRlci50ZXhjb29yZFggKiBjYW52YXMud2lkdGgsIFxyXG4gICAgICAgICAgICBwb2ludGVyLnRleGNvb3JkWSAqIGNhbnZhcy5oZWlnaHQsIFxyXG4gICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICBwb2ludGVyLnRleGNvb3JkWCAqIGNhbnZhcy53aWR0aCwgXHJcbiAgICAgICAgICAgIHBvaW50ZXIudGV4Y29vcmRZICogY2FudmFzLmhlaWdodCwgXHJcbiAgICAgICAgICAgIFNQTEFUX1JBRElVUyAqIE1hdGgubWluKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcclxuICAgICAgICAgICkgOiBudWxsO1xyXG5cclxuICAgICAgICBpZiAoZ3JhZGllbnQpIHtcclxuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBgcmdiYSgke3BvaW50ZXIuY29sb3Iucn0sICR7cG9pbnRlci5jb2xvci5nfSwgJHtwb2ludGVyLmNvbG9yLmJ9LCAke2ludGVuc2l0eSAqIDAuM30pYCk7XHJcbiAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJ3JnYmEoMCwgMCwgMCwgMCknKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBvaW50ZXIubW92ZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYW5pbWF0aW9uSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFdmVudCBsaXN0ZW5lcnNcclxuICAgIGNvbnN0IGhhbmRsZU1vdXNlTW92ZSA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgIHVwZGF0ZVBvaW50ZXIoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVUb3VjaE1vdmUgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHVwZGF0ZVBvaW50ZXIoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlLCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgaGFuZGxlVG91Y2hNb3ZlLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemVcclxuICAgIHJlc2l6ZUNhbnZhcygpO1xyXG4gICAgcG9pbnRlci5jb2xvciA9IGdlbmVyYXRlQ29sb3IoKTtcclxuICAgIGFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XHJcblxyXG4gICAgLy8gQ2xlYW51cFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKGFuaW1hdGlvbklkKSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uSWQpO1xyXG4gICAgICB9XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgaGFuZGxlVG91Y2hNb3ZlKTtcclxuICAgIH07XHJcbiAgfSwgW1xyXG4gICAgU0lNX1JFU09MVVRJT04sXHJcbiAgICBEWUVfUkVTT0xVVElPTixcclxuICAgIERFTlNJVFlfRElTU0lQQVRJT04sXHJcbiAgICBWRUxPQ0lUWV9ESVNTSVBBVElPTixcclxuICAgIFBSRVNTVVJFLFxyXG4gICAgUFJFU1NVUkVfSVRFUkFUSU9OUyxcclxuICAgIENVUkwsXHJcbiAgICBTUExBVF9SQURJVVMsXHJcbiAgICBTUExBVF9GT1JDRSxcclxuICAgIFNIQURJTkcsXHJcbiAgICBDT0xPUl9VUERBVEVfU1BFRUQsXHJcbiAgICBCQUNLX0NPTE9SLFxyXG4gICAgVFJBTlNQQVJFTlRcclxuICBdKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZml4ZWQgdG9wLTAgbGVmdC0wIHotMTAgcG9pbnRlci1ldmVudHMtbm9uZSB3LWZ1bGwgaC1mdWxsIG9wYWNpdHktNDBcIj5cclxuICAgICAgPGNhbnZhcyBcclxuICAgICAgICByZWY9e2NhbnZhc1JlZn0gXHJcbiAgICAgICAgaWQ9XCJmbHVpZFwiIFxyXG4gICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgYmxvY2tcIlxyXG4gICAgICAgIHN0eWxlPXt7IFxyXG4gICAgICAgICAgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgIG1peEJsZW5kTW9kZTogJ211bHRpcGx5JyAvLyBCbGVuZCBtb2RlIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIGZvcm1zXHJcbiAgICAgICAgfX1cclxuICAgICAgLz5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJwb2ludGVyUHJvdG90eXBlIiwiaWQiLCJ0ZXhjb29yZFgiLCJ0ZXhjb29yZFkiLCJwcmV2VGV4Y29vcmRYIiwicHJldlRleGNvb3JkWSIsImRlbHRhWCIsImRlbHRhWSIsImRvd24iLCJtb3ZlZCIsImNvbG9yIiwiciIsImciLCJiIiwiU3BsYXNoQ3Vyc29yIiwiU0lNX1JFU09MVVRJT04iLCJEWUVfUkVTT0xVVElPTiIsIkRFTlNJVFlfRElTU0lQQVRJT04iLCJWRUxPQ0lUWV9ESVNTSVBBVElPTiIsIlBSRVNTVVJFIiwiUFJFU1NVUkVfSVRFUkFUSU9OUyIsIkNVUkwiLCJTUExBVF9SQURJVVMiLCJTUExBVF9GT1JDRSIsIlNIQURJTkciLCJDT0xPUl9VUERBVEVfU1BFRUQiLCJCQUNLX0NPTE9SIiwiVFJBTlNQQVJFTlQiLCJjYW52YXNSZWYiLCJjYW52YXMiLCJjdXJyZW50IiwiYW5pbWF0aW9uSWQiLCJnbCIsImdldENvbnRleHQiLCJlIiwicG9pbnRlciIsImxhc3RUaW1lIiwiY29sb3JUaW1lciIsImxpZ2h0Q29sb3JzIiwiZ2VuZXJhdGVDb2xvciIsInJhbmRvbUNvbG9yIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwibGVuZ3RoIiwicmVzaXplQ2FudmFzIiwiZGlzcGxheVdpZHRoIiwiY2xpZW50V2lkdGgiLCJkaXNwbGF5SGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwid2lkdGgiLCJoZWlnaHQiLCJ2aWV3cG9ydCIsInVwZGF0ZVBvaW50ZXIiLCJ4IiwieSIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJsZWZ0IiwidG9wIiwiYWJzIiwicmVuZGVyIiwiY3VycmVudFRpbWUiLCJkdCIsIm1pbiIsImNsZWFyQ29sb3IiLCJjbGVhciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJpbnRlbnNpdHkiLCJzcXJ0IiwiZ3JhZGllbnQiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImhhbmRsZU1vdXNlTW92ZSIsImNsaWVudFgiLCJjbGllbnRZIiwiaGFuZGxlVG91Y2hNb3ZlIiwicHJldmVudERlZmF1bHQiLCJ0b3VjaGVzIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkaXYiLCJjbGFzc05hbWUiLCJyZWYiLCJzdHlsZSIsImJhY2tncm91bmQiLCJtaXhCbGVuZE1vZGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/SplashCursor.tsx\n"));

/***/ })

});