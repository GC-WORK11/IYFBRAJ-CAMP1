"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/register/page",{

/***/ "(app-pages-browser)/./src/components/Layout/Layout.tsx":
/*!******************************************!*\
  !*** ./src/components/Layout/Layout.tsx ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Layout)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _Header__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Header */ \"(app-pages-browser)/./src/components/Layout/Header.tsx\");\n/* harmony import */ var _Footer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Footer */ \"(app-pages-browser)/./src/components/Layout/Footer.tsx\");\n/* harmony import */ var _StickyFooter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./StickyFooter */ \"(app-pages-browser)/./src/components/Layout/StickyFooter.tsx\");\n/* harmony import */ var _components_SplashCursor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/SplashCursor */ \"(app-pages-browser)/./src/components/SplashCursor.tsx\");\n\n\n\n\n\nfunction Layout(param) {\n    let { children, onRegisterClick } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col min-h-screen\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_SplashCursor__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                fileName: \"E:\\\\IYFDelhi-Braj\\\\iskon-youth-forum\\\\src\\\\components\\\\Layout\\\\Layout.tsx\",\n                lineNumber: 15,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Header__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                onRegisterClick: onRegisterClick\n            }, void 0, false, {\n                fileName: \"E:\\\\IYFDelhi-Braj\\\\iskon-youth-forum\\\\src\\\\components\\\\Layout\\\\Layout.tsx\",\n                lineNumber: 16,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                className: \"flex-grow pt-20 pb-20\",\n                children: children\n            }, void 0, false, {\n                fileName: \"E:\\\\IYFDelhi-Braj\\\\iskon-youth-forum\\\\src\\\\components\\\\Layout\\\\Layout.tsx\",\n                lineNumber: 17,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Footer__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                fileName: \"E:\\\\IYFDelhi-Braj\\\\iskon-youth-forum\\\\src\\\\components\\\\Layout\\\\Layout.tsx\",\n                lineNumber: 20,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_StickyFooter__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                onRegisterClick: onRegisterClick\n            }, void 0, false, {\n                fileName: \"E:\\\\IYFDelhi-Braj\\\\iskon-youth-forum\\\\src\\\\components\\\\Layout\\\\Layout.tsx\",\n                lineNumber: 21,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"E:\\\\IYFDelhi-Braj\\\\iskon-youth-forum\\\\src\\\\components\\\\Layout\\\\Layout.tsx\",\n        lineNumber: 14,\n        columnNumber: 5\n    }, this);\n}\n_c = Layout;\nvar _c;\n$RefreshReg$(_c, \"Layout\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xheW91dC9MYXlvdXQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBOEI7QUFDQTtBQUNZO0FBQ1c7QUFRdEMsU0FBU0ksT0FBTyxLQUEwQztRQUExQyxFQUFFQyxRQUFRLEVBQUVDLGVBQWUsRUFBZSxHQUExQztJQUM3QixxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNMLGdFQUFZQTs7Ozs7MEJBQ2IsOERBQUNILCtDQUFNQTtnQkFBQ00saUJBQWlCQTs7Ozs7OzBCQUN6Qiw4REFBQ0c7Z0JBQUtELFdBQVU7MEJBQ2JIOzs7Ozs7MEJBRUgsOERBQUNKLCtDQUFNQTs7Ozs7MEJBQ1AsOERBQUNDLHFEQUFZQTtnQkFBQ0ksaUJBQWlCQTs7Ozs7Ozs7Ozs7O0FBR3JDO0tBWndCRiIsInNvdXJjZXMiOlsiRTpcXElZRkRlbGhpLUJyYWpcXGlza29uLXlvdXRoLWZvcnVtXFxzcmNcXGNvbXBvbmVudHNcXExheW91dFxcTGF5b3V0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSGVhZGVyIGZyb20gJy4vSGVhZGVyJztcbmltcG9ydCBGb290ZXIgZnJvbSAnLi9Gb290ZXInO1xuaW1wb3J0IFN0aWNreUZvb3RlciBmcm9tICcuL1N0aWNreUZvb3Rlcic7XG5pbXBvcnQgU3BsYXNoQ3Vyc29yIGZyb20gJ0AvY29tcG9uZW50cy9TcGxhc2hDdXJzb3InO1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuXG5pbnRlcmZhY2UgTGF5b3V0UHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3ROb2RlO1xuICBvblJlZ2lzdGVyQ2xpY2s/OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMYXlvdXQoeyBjaGlsZHJlbiwgb25SZWdpc3RlckNsaWNrIH06IExheW91dFByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIG1pbi1oLXNjcmVlblwiPlxuICAgICAgPFNwbGFzaEN1cnNvciAvPlxuICAgICAgPEhlYWRlciBvblJlZ2lzdGVyQ2xpY2s9e29uUmVnaXN0ZXJDbGlja30gLz5cbiAgICAgIDxtYWluIGNsYXNzTmFtZT1cImZsZXgtZ3JvdyBwdC0yMCBwYi0yMFwiPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L21haW4+XG4gICAgICA8Rm9vdGVyIC8+XG4gICAgICA8U3RpY2t5Rm9vdGVyIG9uUmVnaXN0ZXJDbGljaz17b25SZWdpc3RlckNsaWNrfSAvPlxuICAgIDwvZGl2PlxuICApO1xufSJdLCJuYW1lcyI6WyJIZWFkZXIiLCJGb290ZXIiLCJTdGlja3lGb290ZXIiLCJTcGxhc2hDdXJzb3IiLCJMYXlvdXQiLCJjaGlsZHJlbiIsIm9uUmVnaXN0ZXJDbGljayIsImRpdiIsImNsYXNzTmFtZSIsIm1haW4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Layout/Layout.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/SplashCursor.tsx":
/*!*****************************************!*\
  !*** ./src/components/SplashCursor.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SplashCursor)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction SplashCursor(param) {\n    let { SIM_RESOLUTION = 128, DYE_RESOLUTION = 1024, DENSITY_DISSIPATION = 1.2, VELOCITY_DISSIPATION = 0.2, PRESSURE = 0.8, PRESSURE_ITERATIONS = 20, CURL = 30, SPLAT_RADIUS = 0.25, SPLAT_FORCE = 6000, SHADING = true, COLOR_UPDATE_SPEED = 10, BACK_COLOR = {\n        r: 0.05,\n        g: 0.1,\n        b: 0.05\n    }, TRANSPARENT = true } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SplashCursor.useEffect\": ()=>{\n            var _s = $RefreshSig$();\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            let animationId;\n            let gl;\n            let pointers = [];\n            let config = {\n                SIM_RESOLUTION,\n                DYE_RESOLUTION,\n                DENSITY_DISSIPATION,\n                VELOCITY_DISSIPATION,\n                PRESSURE,\n                PRESSURE_ITERATIONS,\n                CURL,\n                SPLAT_RADIUS,\n                SPLAT_FORCE,\n                SHADING,\n                COLOR_UPDATE_SPEED,\n                PAUSED: false,\n                BACK_COLOR,\n                TRANSPARENT\n            };\n            // Initialize WebGL context\n            function initWebGL() {\n                const params = {\n                    alpha: true,\n                    depth: false,\n                    stencil: false,\n                    antialias: false,\n                    preserveDrawingBuffer: false\n                };\n                gl = canvas.getContext('webgl2', params) || canvas.getContext('webgl', params) || canvas.getContext('experimental-webgl', params);\n                if (!gl) {\n                    console.warn('WebGL not supported, splash cursor disabled');\n                    return false;\n                }\n                gl.clearColor(0, 0, 0, 1);\n                return true;\n            }\n            // Resize canvas to match viewport\n            function resizeCanvas() {\n                const pixelRatio = Math.min(window.devicePixelRatio || 1, 2);\n                const width = Math.floor(canvas.clientWidth * pixelRatio);\n                const height = Math.floor(canvas.clientHeight * pixelRatio);\n                if (canvas.width !== width || canvas.height !== height) {\n                    canvas.width = width;\n                    canvas.height = height;\n                    return true;\n                }\n                return false;\n            }\n            // Create pointer object\n            function createPointer() {\n                return {\n                    id: -1,\n                    texcoordX: 0,\n                    texcoordY: 0,\n                    prevTexcoordX: 0,\n                    prevTexcoordY: 0,\n                    deltaX: 0,\n                    deltaY: 0,\n                    down: false,\n                    moved: false,\n                    color: generateColor()\n                };\n            }\n            // Generate random color\n            function generateColor() {\n                const colors = [\n                    {\n                        r: 0.2,\n                        g: 0.8,\n                        b: 0.4\n                    },\n                    {\n                        r: 1.0,\n                        g: 0.6,\n                        b: 0.2\n                    },\n                    {\n                        r: 0.3,\n                        g: 0.9,\n                        b: 0.6\n                    },\n                    {\n                        r: 1.0,\n                        g: 0.8,\n                        b: 0.3\n                    },\n                    {\n                        r: 0.1,\n                        g: 0.7,\n                        b: 0.3\n                    } // Dark green\n                ];\n                return colors[Math.floor(Math.random() * colors.length)];\n            }\n            // Update pointer position\n            function updatePointer(pointer, x, y) {\n                pointer.prevTexcoordX = pointer.texcoordX;\n                pointer.prevTexcoordY = pointer.texcoordY;\n                pointer.texcoordX = x / canvas.width;\n                pointer.texcoordY = 1.0 - y / canvas.height;\n                pointer.deltaX = pointer.texcoordX - pointer.prevTexcoordX;\n                pointer.deltaY = pointer.texcoordY - pointer.prevTexcoordY;\n                pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n            }\n            // Simple fluid simulation\n            function createSimpleFluid() {\n                const vertices = new Float32Array([\n                    -1,\n                    -1,\n                    -1,\n                    1,\n                    1,\n                    1,\n                    1,\n                    -1\n                ]);\n                const indices = new Uint16Array([\n                    0,\n                    1,\n                    2,\n                    0,\n                    2,\n                    3\n                ]);\n                const vertexBuffer = gl.createBuffer();\n                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n                const indexBuffer = gl.createBuffer();\n                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\n                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);\n                // Simple vertex shader\n                const vertexShaderSource = \"\\n        attribute vec2 position;\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = position * 0.5 + 0.5;\\n          gl_Position = vec4(position, 0.0, 1.0);\\n        }\\n      \";\n                // Simple fragment shader with fluid-like effect\n                const fragmentShaderSource = \"\\n        precision mediump float;\\n        varying vec2 vUv;\\n        uniform float time;\\n        uniform vec2 resolution;\\n        uniform vec2 pointers[10];\\n        uniform vec3 colors[10];\\n        uniform int pointerCount;\\n\\n        void main() {\\n          vec2 uv = vUv;\\n          vec3 color = vec3(0.02, 0.05, 0.02);\\n          \\n          for(int i = 0; i < 10; i++) {\\n            if(i >= pointerCount) break;\\n            \\n            vec2 pointer = pointers[i];\\n            float dist = distance(uv, pointer);\\n            float influence = 1.0 / (1.0 + dist * 20.0);\\n            influence = smoothstep(0.0, 1.0, influence);\\n            \\n            vec3 pointerColor = colors[i];\\n            color += pointerColor * influence * 0.5;\\n          }\\n          \\n          // Add some movement\\n          color += sin(uv.x * 10.0 + time) * sin(uv.y * 10.0 + time) * 0.02;\\n          \\n          gl_FragColor = vec4(color, 0.8);\\n        }\\n      \";\n                function createShader(type, source) {\n                    const shader = gl.createShader(type);\n                    if (!shader) return null;\n                    gl.shaderSource(shader, source);\n                    gl.compileShader(shader);\n                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                        console.error('Shader compile error:', gl.getShaderInfoLog(shader));\n                        gl.deleteShader(shader);\n                        return null;\n                    }\n                    return shader;\n                }\n                const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);\n                const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);\n                if (!vertexShader || !fragmentShader) return null;\n                const program = gl.createProgram();\n                if (!program) return null;\n                gl.attachShader(program, vertexShader);\n                gl.attachShader(program, fragmentShader);\n                gl.linkProgram(program);\n                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n                    console.error('Program link error:', gl.getProgramInfoLog(program));\n                    return null;\n                }\n                return {\n                    program,\n                    attributes: {\n                        position: gl.getAttribLocation(program, 'position')\n                    },\n                    uniforms: {\n                        time: gl.getUniformLocation(program, 'time'),\n                        resolution: gl.getUniformLocation(program, 'resolution'),\n                        pointers: gl.getUniformLocation(program, 'pointers'),\n                        colors: gl.getUniformLocation(program, 'colors'),\n                        pointerCount: gl.getUniformLocation(program, 'pointerCount')\n                    }\n                };\n            }\n            // Initialize\n            if (!initWebGL()) return;\n            const fluidProgram = createSimpleFluid();\n            if (!fluidProgram) return;\n            // Initialize single pointer\n            pointers = [\n                createPointer()\n            ];\n            // Set initial canvas size\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n            resizeCanvas();\n            let startTime = Date.now();\n            // Render loop\n            function render() {\n                _s();\n                resizeCanvas();\n                const currentTime = (Date.now() - startTime) * 0.001;\n                gl.viewport(0, 0, canvas.width, canvas.height);\n                gl.clear(gl.COLOR_BUFFER_BIT);\n                gl.useProgram(fluidProgram.program);\n                // Set uniforms\n                gl.uniform1f(fluidProgram.uniforms.time, currentTime);\n                gl.uniform2f(fluidProgram.uniforms.resolution, canvas.width, canvas.height);\n                gl.uniform1i(fluidProgram.uniforms.pointerCount, pointers.length);\n                // Set pointer positions and colors\n                const pointerPositions = new Float32Array(20); // 10 pointers * 2 coordinates\n                const pointerColors = new Float32Array(30); // 10 pointers * 3 colors\n                for(let i = 0; i < Math.min(pointers.length, 10); i++){\n                    pointerPositions[i * 2] = pointers[i].texcoordX;\n                    pointerPositions[i * 2 + 1] = pointers[i].texcoordY;\n                    pointerColors[i * 3] = pointers[i].color.r;\n                    pointerColors[i * 3 + 1] = pointers[i].color.g;\n                    pointerColors[i * 3 + 2] = pointers[i].color.b;\n                }\n                gl.uniform2fv(fluidProgram.uniforms.pointers, pointerPositions);\n                gl.uniform3fv(fluidProgram.uniforms.colors, pointerColors);\n                // Set attributes\n                gl.enableVertexAttribArray(fluidProgram.attributes.position);\n                gl.vertexAttribPointer(fluidProgram.attributes.position, 2, gl.FLOAT, false, 0, 0);\n                // Draw\n                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n                animationId = requestAnimationFrame(render);\n            }\n            _s(render, \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", false, function() {\n                return [\n                    gl.useProgram\n                ];\n            });\n            // Mouse events\n            function handleMouseMove(e) {\n                const rect = canvas.getBoundingClientRect();\n                const x = (e.clientX - rect.left) * (canvas.width / rect.width);\n                const y = (e.clientY - rect.top) * (canvas.height / rect.height);\n                updatePointer(pointers[0], x, y);\n                pointers[0].down = true;\n            }\n            function handleMouseDown(e) {\n                const rect = canvas.getBoundingClientRect();\n                const x = (e.clientX - rect.left) * (canvas.width / rect.width);\n                const y = (e.clientY - rect.top) * (canvas.height / rect.height);\n                updatePointer(pointers[0], x, y);\n                pointers[0].down = true;\n                pointers[0].color = generateColor();\n            }\n            function handleMouseUp() {\n                pointers[0].down = false;\n            }\n            // Touch events for mobile\n            function handleTouchStart(e) {\n                e.preventDefault();\n                const rect = canvas.getBoundingClientRect();\n                const touch = e.touches[0];\n                const x = (touch.clientX - rect.left) * (canvas.width / rect.width);\n                const y = (touch.clientY - rect.top) * (canvas.height / rect.height);\n                updatePointer(pointers[0], x, y);\n                pointers[0].down = true;\n                pointers[0].color = generateColor();\n            }\n            function handleTouchMove(e) {\n                e.preventDefault();\n                const rect = canvas.getBoundingClientRect();\n                const touch = e.touches[0];\n                const x = (touch.clientX - rect.left) * (canvas.width / rect.width);\n                const y = (touch.clientY - rect.top) * (canvas.height / rect.height);\n                updatePointer(pointers[0], x, y);\n                pointers[0].down = true;\n            }\n            function handleTouchEnd(e) {\n                e.preventDefault();\n                pointers[0].down = false;\n            }\n            // Add event listeners\n            canvas.addEventListener('mousemove', handleMouseMove, {\n                passive: true\n            });\n            canvas.addEventListener('mousedown', handleMouseDown, {\n                passive: true\n            });\n            canvas.addEventListener('mouseup', handleMouseUp, {\n                passive: true\n            });\n            canvas.addEventListener('touchstart', handleTouchStart, {\n                passive: false\n            });\n            canvas.addEventListener('touchmove', handleTouchMove, {\n                passive: false\n            });\n            canvas.addEventListener('touchend', handleTouchEnd, {\n                passive: false\n            });\n            // Handle window resize\n            function handleResize() {\n                canvas.width = window.innerWidth;\n                canvas.height = window.innerHeight;\n                resizeCanvas();\n            }\n            window.addEventListener('resize', handleResize);\n            // Start render loop\n            render();\n            // Cleanup\n            return ({\n                \"SplashCursor.useEffect\": ()=>{\n                    cancelAnimationFrame(animationId);\n                    canvas.removeEventListener('mousemove', handleMouseMove);\n                    canvas.removeEventListener('mousedown', handleMouseDown);\n                    canvas.removeEventListener('mouseup', handleMouseUp);\n                    canvas.removeEventListener('touchstart', handleTouchStart);\n                    canvas.removeEventListener('touchmove', handleTouchMove);\n                    canvas.removeEventListener('touchend', handleTouchEnd);\n                    window.removeEventListener('resize', handleResize);\n                }\n            })[\"SplashCursor.useEffect\"];\n        }\n    }[\"SplashCursor.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        id: \"splash-cursor\",\n        className: \"fixed inset-0 w-full h-full pointer-events-none z-0\",\n        style: {\n            width: '100vw',\n            height: '100vh',\n            touchAction: 'none'\n        }\n    }, void 0, false, {\n        fileName: \"E:\\\\IYFDelhi-Braj\\\\iskon-youth-forum\\\\src\\\\components\\\\SplashCursor.tsx\",\n        lineNumber: 396,\n        columnNumber: 5\n    }, this);\n}\n_s(SplashCursor, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = SplashCursor;\nvar _c;\n$RefreshReg$(_c, \"SplashCursor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1NwbGFzaEN1cnNvci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQ2lEO0FBcUNsQyxTQUFTRyxhQUFhLEtBY2pCO1FBZGlCLEVBQ25DQyxpQkFBaUIsR0FBRyxFQUNwQkMsaUJBQWlCLElBQUksRUFDckJDLHNCQUFzQixHQUFHLEVBQ3pCQyx1QkFBdUIsR0FBRyxFQUMxQkMsV0FBVyxHQUFHLEVBQ2RDLHNCQUFzQixFQUFFLEVBQ3hCQyxPQUFPLEVBQUUsRUFDVEMsZUFBZSxJQUFJLEVBQ25CQyxjQUFjLElBQUksRUFDbEJDLFVBQVUsSUFBSSxFQUNkQyxxQkFBcUIsRUFBRSxFQUN2QkMsYUFBYTtRQUFFQyxHQUFHO1FBQU1DLEdBQUc7UUFBS0MsR0FBRztJQUFLLENBQUMsRUFDekNDLGNBQWMsSUFBSSxFQUNBLEdBZGlCOztJQWVuQyxNQUFNQyxZQUFZbEIsNkNBQU1BLENBQW9CO0lBRTVDRCxnREFBU0E7a0NBQUM7O1lBQ1IsTUFBTW9CLFNBQVNELFVBQVVFLE9BQU87WUFDaEMsSUFBSSxDQUFDRCxRQUFRO1lBRWIsSUFBSUU7WUFDSixJQUFJQztZQUNKLElBQUlDLFdBQXNCLEVBQUU7WUFDNUIsSUFBSUMsU0FBUztnQkFDWHRCO2dCQUNBQztnQkFDQUM7Z0JBQ0FDO2dCQUNBQztnQkFDQUM7Z0JBQ0FDO2dCQUNBQztnQkFDQUM7Z0JBQ0FDO2dCQUNBQztnQkFDQWEsUUFBUTtnQkFDUlo7Z0JBQ0FJO1lBQ0Y7WUFFQSwyQkFBMkI7WUFDM0IsU0FBU1M7Z0JBQ1AsTUFBTUMsU0FBUztvQkFDYkMsT0FBTztvQkFDUEMsT0FBTztvQkFDUEMsU0FBUztvQkFDVEMsV0FBVztvQkFDWEMsdUJBQXVCO2dCQUN6QjtnQkFFQVYsS0FBS0gsT0FBT2MsVUFBVSxDQUFDLFVBQVVOLFdBQzVCUixPQUFPYyxVQUFVLENBQUMsU0FBU04sV0FDM0JSLE9BQU9jLFVBQVUsQ0FBQyxzQkFBc0JOO2dCQUU3QyxJ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O29CQUN6Q25JLE9BQU82SSxtQkFBbUIsQ0FBQyxhQUFhTjtvQkFDeEN2SSxPQUFPNkksbUJBQW1CLENBQUMsWUFBWUw7b0JBQ3ZDbEgsT0FBT3VILG1CQUFtQixDQUFDLFVBQVVGO2dCQUN2Qzs7UUFDRjtpQ0FBRyxFQUFFO0lBRUwscUJBQ0UsOERBQUMzSTtRQUNDOEksS0FBSy9JO1FBQ0wrQixJQUFHO1FBQ0hpSCxXQUFVO1FBQ1ZDLE9BQU87WUFDTHhILE9BQU87WUFDUEcsUUFBUTtZQUNSc0gsYUFBYTtRQUNmOzs7Ozs7QUFHTjtHQWhYd0JuSztLQUFBQSIsInNvdXJjZXMiOlsiRTpcXElZRkRlbGhpLUJyYWpcXGlza29uLXlvdXRoLWZvcnVtXFxzcmNcXGNvbXBvbmVudHNcXFNwbGFzaEN1cnNvci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5pbnRlcmZhY2UgQ29sb3JSR0Ige1xyXG4gIHI6IG51bWJlcjtcclxuICBnOiBudW1iZXI7XHJcbiAgYjogbnVtYmVyO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU3BsYXNoQ3Vyc29yUHJvcHMge1xyXG4gIFNJTV9SRVNPTFVUSU9OPzogbnVtYmVyO1xyXG4gIERZRV9SRVNPTFVUSU9OPzogbnVtYmVyO1xyXG4gIERFTlNJVFlfRElTU0lQQVRJT04/OiBudW1iZXI7XHJcbiAgVkVMT0NJVFlfRElTU0lQQVRJT04/OiBudW1iZXI7XHJcbiAgUFJFU1NVUkU/OiBudW1iZXI7XHJcbiAgUFJFU1NVUkVfSVRFUkFUSU9OUz86IG51bWJlcjtcclxuICBDVVJMPzogbnVtYmVyO1xyXG4gIFNQTEFUX1JBRElVUz86IG51bWJlcjtcclxuICBTUExBVF9GT1JDRT86IG51bWJlcjtcclxuICBTSEFESU5HPzogYm9vbGVhbjtcclxuICBDT0xPUl9VUERBVEVfU1BFRUQ/OiBudW1iZXI7XHJcbiAgQkFDS19DT0xPUj86IENvbG9yUkdCO1xyXG4gIFRSQU5TUEFSRU5UPzogYm9vbGVhbjtcclxufVxyXG5cclxuaW50ZXJmYWNlIFBvaW50ZXIge1xyXG4gIGlkOiBudW1iZXI7XHJcbiAgdGV4Y29vcmRYOiBudW1iZXI7XHJcbiAgdGV4Y29vcmRZOiBudW1iZXI7XHJcbiAgcHJldlRleGNvb3JkWDogbnVtYmVyO1xyXG4gIHByZXZUZXhjb29yZFk6IG51bWJlcjtcclxuICBkZWx0YVg6IG51bWJlcjtcclxuICBkZWx0YVk6IG51bWJlcjtcclxuICBkb3duOiBib29sZWFuO1xyXG4gIG1vdmVkOiBib29sZWFuO1xyXG4gIGNvbG9yOiBDb2xvclJHQjtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3BsYXNoQ3Vyc29yKHtcclxuICBTSU1fUkVTT0xVVElPTiA9IDEyOCxcclxuICBEWUVfUkVTT0xVVElPTiA9IDEwMjQsXHJcbiAgREVOU0lUWV9ESVNTSVBBVElPTiA9IDEuMixcclxuICBWRUxPQ0lUWV9ESVNTSVBBVElPTiA9IDAuMixcclxuICBQUkVTU1VSRSA9IDAuOCxcclxuICBQUkVTU1VSRV9JVEVSQVRJT05TID0gMjAsXHJcbiAgQ1VSTCA9IDMwLFxyXG4gIFNQTEFUX1JBRElVUyA9IDAuMjUsXHJcbiAgU1BMQVRfRk9SQ0UgPSA2MDAwLFxyXG4gIFNIQURJTkcgPSB0cnVlLFxyXG4gIENPTE9SX1VQREFURV9TUEVFRCA9IDEwLFxyXG4gIEJBQ0tfQ09MT1IgPSB7IHI6IDAuMDUsIGc6IDAuMSwgYjogMC4wNSB9LFxyXG4gIFRSQU5TUEFSRU5UID0gdHJ1ZVxyXG59OiBTcGxhc2hDdXJzb3JQcm9wcykge1xyXG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgIGlmICghY2FudmFzKSByZXR1cm47XHJcblxyXG4gICAgbGV0IGFuaW1hdGlvbklkOiBudW1iZXI7XHJcbiAgICBsZXQgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgfCBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICBsZXQgcG9pbnRlcnM6IFBvaW50ZXJbXSA9IFtdO1xyXG4gICAgbGV0IGNvbmZpZyA9IHtcclxuICAgICAgU0lNX1JFU09MVVRJT04sXHJcbiAgICAgIERZRV9SRVNPTFVUSU9OLFxyXG4gICAgICBERU5TSVRZX0RJU1NJUEFUSU9OLFxyXG4gICAgICBWRUxPQ0lUWV9ESVNTSVBBVElPTixcclxuICAgICAgUFJFU1NVUkUsXHJcbiAgICAgIFBSRVNTVVJFX0lURVJBVElPTlMsXHJcbiAgICAgIENVUkwsXHJcbiAgICAgIFNQTEFUX1JBRElVUyxcclxuICAgICAgU1BMQVRfRk9SQ0UsXHJcbiAgICAgIFNIQURJTkcsXHJcbiAgICAgIENPTE9SX1VQREFURV9TUEVFRCxcclxuICAgICAgUEFVU0VEOiBmYWxzZSxcclxuICAgICAgQkFDS19DT0xPUixcclxuICAgICAgVFJBTlNQQVJFTlRcclxuICAgIH07XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBXZWJHTCBjb250ZXh0XHJcbiAgICBmdW5jdGlvbiBpbml0V2ViR0woKSB7XHJcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcclxuICAgICAgICBhbHBoYTogdHJ1ZSxcclxuICAgICAgICBkZXB0aDogZmFsc2UsXHJcbiAgICAgICAgc3RlbmNpbDogZmFsc2UsXHJcbiAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcclxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBwYXJhbXMpIHx8IFxyXG4gICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIHBhcmFtcykgfHwgXHJcbiAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIHBhcmFtcykgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcclxuXHJcbiAgICAgIGlmICghZ2wpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ1dlYkdMIG5vdCBzdXBwb3J0ZWQsIHNwbGFzaCBjdXJzb3IgZGlzYWJsZWQnKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMSk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2l6ZSBjYW52YXMgdG8gbWF0Y2ggdmlld3BvcnRcclxuICAgIGZ1bmN0aW9uIHJlc2l6ZUNhbnZhcygpIHtcclxuICAgICAgY29uc3QgcGl4ZWxSYXRpbyA9IE1hdGgubWluKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsIDIpO1xyXG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGguZmxvb3IoY2FudmFzLmNsaWVudFdpZHRoICogcGl4ZWxSYXRpbyk7XHJcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguZmxvb3IoY2FudmFzLmNsaWVudEhlaWdodCAqIHBpeGVsUmF0aW8pO1xyXG4gICAgICBcclxuICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gd2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gaGVpZ2h0KSB7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIHBvaW50ZXIgb2JqZWN0XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVQb2ludGVyKCk6IFBvaW50ZXIge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiAtMSxcclxuICAgICAgICB0ZXhjb29yZFg6IDAsXHJcbiAgICAgICAgdGV4Y29vcmRZOiAwLFxyXG4gICAgICAgIHByZXZUZXhjb29yZFg6IDAsXHJcbiAgICAgICAgcHJldlRleGNvb3JkWTogMCxcclxuICAgICAgICBkZWx0YVg6IDAsXHJcbiAgICAgICAgZGVsdGFZOiAwLFxyXG4gICAgICAgIGRvd246IGZhbHNlLFxyXG4gICAgICAgIG1vdmVkOiBmYWxzZSxcclxuICAgICAgICBjb2xvcjogZ2VuZXJhdGVDb2xvcigpXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgcmFuZG9tIGNvbG9yXHJcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNvbG9yKCk6IENvbG9yUkdCIHtcclxuICAgICAgY29uc3QgY29sb3JzID0gW1xyXG4gICAgICAgIHsgcjogMC4yLCBnOiAwLjgsIGI6IDAuNCB9LCAvLyBFbWVyYWxkXHJcbiAgICAgICAgeyByOiAxLjAsIGc6IDAuNiwgYjogMC4yIH0sIC8vIE9yYW5nZVxyXG4gICAgICAgIHsgcjogMC4zLCBnOiAwLjksIGI6IDAuNiB9LCAvLyBMaWdodCBncmVlblxyXG4gICAgICAgIHsgcjogMS4wLCBnOiAwLjgsIGI6IDAuMyB9LCAvLyBMaWdodCBvcmFuZ2VcclxuICAgICAgICB7IHI6IDAuMSwgZzogMC43LCBiOiAwLjMgfSAgLy8gRGFyayBncmVlblxyXG4gICAgICBdO1xyXG4gICAgICByZXR1cm4gY29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNvbG9ycy5sZW5ndGgpXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBVcGRhdGUgcG9pbnRlciBwb3NpdGlvblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9pbnRlcihwb2ludGVyOiBQb2ludGVyLCB4OiBudW1iZXIsIHk6IG51bWJlcikge1xyXG4gICAgICBwb2ludGVyLnByZXZUZXhjb29yZFggPSBwb2ludGVyLnRleGNvb3JkWDtcclxuICAgICAgcG9pbnRlci5wcmV2VGV4Y29vcmRZID0gcG9pbnRlci50ZXhjb29yZFk7XHJcbiAgICAgIHBvaW50ZXIudGV4Y29vcmRYID0geCAvIGNhbnZhcy53aWR0aDtcclxuICAgICAgcG9pbnRlci50ZXhjb29yZFkgPSAxLjAgLSB5IC8gY2FudmFzLmhlaWdodDtcclxuICAgICAgcG9pbnRlci5kZWx0YVggPSBwb2ludGVyLnRleGNvb3JkWCAtIHBvaW50ZXIucHJldlRleGNvb3JkWDtcclxuICAgICAgcG9pbnRlci5kZWx0YVkgPSBwb2ludGVyLnRleGNvb3JkWSAtIHBvaW50ZXIucHJldlRleGNvb3JkWTtcclxuICAgICAgcG9pbnRlci5tb3ZlZCA9IE1hdGguYWJzKHBvaW50ZXIuZGVsdGFYKSA+IDAgfHwgTWF0aC5hYnMocG9pbnRlci5kZWx0YVkpID4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTaW1wbGUgZmx1aWQgc2ltdWxhdGlvblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlU2ltcGxlRmx1aWQoKSB7XHJcbiAgICAgIGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbLTEsIC0xLCAtMSwgMSwgMSwgMSwgMSwgLTFdKTtcclxuICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMCwgMiwgM10pO1xyXG5cclxuICAgICAgY29uc3QgdmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIpO1xyXG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgIGNvbnN0IGluZGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4QnVmZmVyKTtcclxuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgLy8gU2ltcGxlIHZlcnRleCBzaGFkZXJcclxuICAgICAgY29uc3QgdmVydGV4U2hhZGVyU291cmNlID0gYFxyXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xyXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XHJcbiAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgdlV2ID0gcG9zaXRpb24gKiAwLjUgKyAwLjU7XHJcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAuMCwgMS4wKTtcclxuICAgICAgICB9XHJcbiAgICAgIGA7XHJcblxyXG4gICAgICAvLyBTaW1wbGUgZnJhZ21lbnQgc2hhZGVyIHdpdGggZmx1aWQtbGlrZSBlZmZlY3RcclxuICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXHJcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcclxuICAgICAgICB1bmlmb3JtIGZsb2F0IHRpbWU7XHJcbiAgICAgICAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XHJcbiAgICAgICAgdW5pZm9ybSB2ZWMyIHBvaW50ZXJzWzEwXTtcclxuICAgICAgICB1bmlmb3JtIHZlYzMgY29sb3JzWzEwXTtcclxuICAgICAgICB1bmlmb3JtIGludCBwb2ludGVyQ291bnQ7XHJcblxyXG4gICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgIHZlYzIgdXYgPSB2VXY7XHJcbiAgICAgICAgICB2ZWMzIGNvbG9yID0gdmVjMygwLjAyLCAwLjA1LCAwLjAyKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgZm9yKGludCBpID0gMDsgaSA8IDEwOyBpKyspIHtcclxuICAgICAgICAgICAgaWYoaSA+PSBwb2ludGVyQ291bnQpIGJyZWFrO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmVjMiBwb2ludGVyID0gcG9pbnRlcnNbaV07XHJcbiAgICAgICAgICAgIGZsb2F0IGRpc3QgPSBkaXN0YW5jZSh1diwgcG9pbnRlcik7XHJcbiAgICAgICAgICAgIGZsb2F0IGluZmx1ZW5jZSA9IDEuMCAvICgxLjAgKyBkaXN0ICogMjAuMCk7XHJcbiAgICAgICAgICAgIGluZmx1ZW5jZSA9IHNtb290aHN0ZXAoMC4wLCAxLjAsIGluZmx1ZW5jZSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2ZWMzIHBvaW50ZXJDb2xvciA9IGNvbG9yc1tpXTtcclxuICAgICAgICAgICAgY29sb3IgKz0gcG9pbnRlckNvbG9yICogaW5mbHVlbmNlICogMC41O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBBZGQgc29tZSBtb3ZlbWVudFxyXG4gICAgICAgICAgY29sb3IgKz0gc2luKHV2LnggKiAxMC4wICsgdGltZSkgKiBzaW4odXYueSAqIDEwLjAgKyB0aW1lKSAqIDAuMDI7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDAuOCk7XHJcbiAgICAgICAgfVxyXG4gICAgICBgO1xyXG5cclxuICAgICAgZnVuY3Rpb24gY3JlYXRlU2hhZGVyKHR5cGU6IG51bWJlciwgc291cmNlOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XHJcbiAgICAgICAgaWYgKCFzaGFkZXIpIHJldHVybiBudWxsO1xyXG4gICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XHJcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdTaGFkZXIgY29tcGlsZSBlcnJvcjonLCBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xyXG4gICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgdmVydGV4U2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleFNoYWRlclNvdXJjZSk7XHJcbiAgICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xyXG5cclxuICAgICAgaWYgKCF2ZXJ0ZXhTaGFkZXIgfHwgIWZyYWdtZW50U2hhZGVyKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgIGlmICghcHJvZ3JhbSkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcclxuICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcblxyXG4gICAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignUHJvZ3JhbSBsaW5rIGVycm9yOicsIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBwcm9ncmFtLFxyXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcclxuICAgICAgICAgIHBvc2l0aW9uOiBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAncG9zaXRpb24nKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW5pZm9ybXM6IHtcclxuICAgICAgICAgIHRpbWU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndGltZScpLFxyXG4gICAgICAgICAgcmVzb2x1dGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdyZXNvbHV0aW9uJyksXHJcbiAgICAgICAgICBwb2ludGVyczogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdwb2ludGVycycpLFxyXG4gICAgICAgICAgY29sb3JzOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2NvbG9ycycpLFxyXG4gICAgICAgICAgcG9pbnRlckNvdW50OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3BvaW50ZXJDb3VudCcpXHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluaXRpYWxpemVcclxuICAgIGlmICghaW5pdFdlYkdMKCkpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBmbHVpZFByb2dyYW0gPSBjcmVhdGVTaW1wbGVGbHVpZCgpO1xyXG4gICAgaWYgKCFmbHVpZFByb2dyYW0pIHJldHVybjtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIHNpbmdsZSBwb2ludGVyXHJcbiAgICBwb2ludGVycyA9IFtjcmVhdGVQb2ludGVyKCldO1xyXG5cclxuICAgIC8vIFNldCBpbml0aWFsIGNhbnZhcyBzaXplXHJcbiAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICByZXNpemVDYW52YXMoKTtcclxuXHJcbiAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAvLyBSZW5kZXIgbG9vcFxyXG4gICAgZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgICByZXNpemVDYW52YXMoKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gKERhdGUubm93KCkgLSBzdGFydFRpbWUpICogMC4wMDE7XHJcbiAgICAgIFxyXG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuICAgICAgXHJcbiAgICAgIGdsLnVzZVByb2dyYW0oZmx1aWRQcm9ncmFtLnByb2dyYW0pO1xyXG4gICAgICBcclxuICAgICAgLy8gU2V0IHVuaWZvcm1zXHJcbiAgICAgIGdsLnVuaWZvcm0xZihmbHVpZFByb2dyYW0udW5pZm9ybXMudGltZSwgY3VycmVudFRpbWUpO1xyXG4gICAgICBnbC51bmlmb3JtMmYoZmx1aWRQcm9ncmFtLnVuaWZvcm1zLnJlc29sdXRpb24sIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgIGdsLnVuaWZvcm0xaShmbHVpZFByb2dyYW0udW5pZm9ybXMucG9pbnRlckNvdW50LCBwb2ludGVycy5sZW5ndGgpO1xyXG4gICAgICBcclxuICAgICAgLy8gU2V0IHBvaW50ZXIgcG9zaXRpb25zIGFuZCBjb2xvcnNcclxuICAgICAgY29uc3QgcG9pbnRlclBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoMjApOyAvLyAxMCBwb2ludGVycyAqIDIgY29vcmRpbmF0ZXNcclxuICAgICAgY29uc3QgcG9pbnRlckNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoMzApOyAvLyAxMCBwb2ludGVycyAqIDMgY29sb3JzXHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKHBvaW50ZXJzLmxlbmd0aCwgMTApOyBpKyspIHtcclxuICAgICAgICBwb2ludGVyUG9zaXRpb25zW2kgKiAyXSA9IHBvaW50ZXJzW2ldLnRleGNvb3JkWDtcclxuICAgICAgICBwb2ludGVyUG9zaXRpb25zW2kgKiAyICsgMV0gPSBwb2ludGVyc1tpXS50ZXhjb29yZFk7XHJcbiAgICAgICAgcG9pbnRlckNvbG9yc1tpICogM10gPSBwb2ludGVyc1tpXS5jb2xvci5yO1xyXG4gICAgICAgIHBvaW50ZXJDb2xvcnNbaSAqIDMgKyAxXSA9IHBvaW50ZXJzW2ldLmNvbG9yLmc7XHJcbiAgICAgICAgcG9pbnRlckNvbG9yc1tpICogMyArIDJdID0gcG9pbnRlcnNbaV0uY29sb3IuYjtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgZ2wudW5pZm9ybTJmdihmbHVpZFByb2dyYW0udW5pZm9ybXMucG9pbnRlcnMsIHBvaW50ZXJQb3NpdGlvbnMpO1xyXG4gICAgICBnbC51bmlmb3JtM2Z2KGZsdWlkUHJvZ3JhbS51bmlmb3Jtcy5jb2xvcnMsIHBvaW50ZXJDb2xvcnMpO1xyXG4gICAgICBcclxuICAgICAgLy8gU2V0IGF0dHJpYnV0ZXNcclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoZmx1aWRQcm9ncmFtLmF0dHJpYnV0ZXMucG9zaXRpb24pO1xyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGZsdWlkUHJvZ3JhbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICBcclxuICAgICAgLy8gRHJhd1xyXG4gICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcbiAgICAgIFxyXG4gICAgICBhbmltYXRpb25JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1vdXNlIGV2ZW50c1xyXG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGU6IE1vdXNlRXZlbnQpIHtcclxuICAgICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgY29uc3QgeCA9IChlLmNsaWVudFggLSByZWN0LmxlZnQpICogKGNhbnZhcy53aWR0aCAvIHJlY3Qud2lkdGgpO1xyXG4gICAgICBjb25zdCB5ID0gKGUuY2xpZW50WSAtIHJlY3QudG9wKSAqIChjYW52YXMuaGVpZ2h0IC8gcmVjdC5oZWlnaHQpO1xyXG4gICAgICB1cGRhdGVQb2ludGVyKHBvaW50ZXJzWzBdLCB4LCB5KTtcclxuICAgICAgcG9pbnRlcnNbMF0uZG93biA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGU6IE1vdXNlRXZlbnQpIHtcclxuICAgICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgY29uc3QgeCA9IChlLmNsaWVudFggLSByZWN0LmxlZnQpICogKGNhbnZhcy53aWR0aCAvIHJlY3Qud2lkdGgpO1xyXG4gICAgICBjb25zdCB5ID0gKGUuY2xpZW50WSAtIHJlY3QudG9wKSAqIChjYW52YXMuaGVpZ2h0IC8gcmVjdC5oZWlnaHQpO1xyXG4gICAgICB1cGRhdGVQb2ludGVyKHBvaW50ZXJzWzBdLCB4LCB5KTtcclxuICAgICAgcG9pbnRlcnNbMF0uZG93biA9IHRydWU7XHJcbiAgICAgIHBvaW50ZXJzWzBdLmNvbG9yID0gZ2VuZXJhdGVDb2xvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoKSB7XHJcbiAgICAgIHBvaW50ZXJzWzBdLmRvd24gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUb3VjaCBldmVudHMgZm9yIG1vYmlsZVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydChlOiBUb3VjaEV2ZW50KSB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgY29uc3QgdG91Y2ggPSBlLnRvdWNoZXNbMF07XHJcbiAgICAgIGNvbnN0IHggPSAodG91Y2guY2xpZW50WCAtIHJlY3QubGVmdCkgKiAoY2FudmFzLndpZHRoIC8gcmVjdC53aWR0aCk7XHJcbiAgICAgIGNvbnN0IHkgPSAodG91Y2guY2xpZW50WSAtIHJlY3QudG9wKSAqIChjYW52YXMuaGVpZ2h0IC8gcmVjdC5oZWlnaHQpO1xyXG4gICAgICB1cGRhdGVQb2ludGVyKHBvaW50ZXJzWzBdLCB4LCB5KTtcclxuICAgICAgcG9pbnRlcnNbMF0uZG93biA9IHRydWU7XHJcbiAgICAgIHBvaW50ZXJzWzBdLmNvbG9yID0gZ2VuZXJhdGVDb2xvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZShlOiBUb3VjaEV2ZW50KSB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgY29uc3QgdG91Y2ggPSBlLnRvdWNoZXNbMF07XHJcbiAgICAgIGNvbnN0IHggPSAodG91Y2guY2xpZW50WCAtIHJlY3QubGVmdCkgKiAoY2FudmFzLndpZHRoIC8gcmVjdC53aWR0aCk7XHJcbiAgICAgIGNvbnN0IHkgPSAodG91Y2guY2xpZW50WSAtIHJlY3QudG9wKSAqIChjYW52YXMuaGVpZ2h0IC8gcmVjdC5oZWlnaHQpO1xyXG4gICAgICB1cGRhdGVQb2ludGVyKHBvaW50ZXJzWzBdLCB4LCB5KTtcclxuICAgICAgcG9pbnRlcnNbMF0uZG93biA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hFbmQoZTogVG91Y2hFdmVudCkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIHBvaW50ZXJzWzBdLmRvd24gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlLCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlTW91c2VEb3duLCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZU1vdXNlVXAsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgaGFuZGxlVG91Y2hTdGFydCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBoYW5kbGVUb3VjaE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XHJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBoYW5kbGVUb3VjaEVuZCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcclxuXHJcbiAgICAvLyBIYW5kbGUgd2luZG93IHJlc2l6ZVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzaXplKCkge1xyXG4gICAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgICAgcmVzaXplQ2FudmFzKCk7XHJcbiAgICB9XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuXHJcbiAgICAvLyBTdGFydCByZW5kZXIgbG9vcFxyXG4gICAgcmVuZGVyKCk7XHJcblxyXG4gICAgLy8gQ2xlYW51cFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uSWQpO1xyXG4gICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcclxuICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZU1vdXNlRG93bik7XHJcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlTW91c2VVcCk7XHJcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgaGFuZGxlVG91Y2hTdGFydCk7XHJcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBoYW5kbGVUb3VjaE1vdmUpO1xyXG4gICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBoYW5kbGVUb3VjaEVuZCk7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xyXG4gICAgfTtcclxuICB9LCBbXSk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8Y2FudmFzXHJcbiAgICAgIHJlZj17Y2FudmFzUmVmfVxyXG4gICAgICBpZD1cInNwbGFzaC1jdXJzb3JcIlxyXG4gICAgICBjbGFzc05hbWU9XCJmaXhlZCBpbnNldC0wIHctZnVsbCBoLWZ1bGwgcG9pbnRlci1ldmVudHMtbm9uZSB6LTBcIlxyXG4gICAgICBzdHlsZT17e1xyXG4gICAgICAgIHdpZHRoOiAnMTAwdncnLFxyXG4gICAgICAgIGhlaWdodDogJzEwMHZoJyxcclxuICAgICAgICB0b3VjaEFjdGlvbjogJ25vbmUnXHJcbiAgICAgIH19XHJcbiAgICAvPlxyXG4gICk7XHJcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJTcGxhc2hDdXJzb3IiLCJTSU1fUkVTT0xVVElPTiIsIkRZRV9SRVNPTFVUSU9OIiwiREVOU0lUWV9ESVNTSVBBVElPTiIsIlZFTE9DSVRZX0RJU1NJUEFUSU9OIiwiUFJFU1NVUkUiLCJQUkVTU1VSRV9JVEVSQVRJT05TIiwiQ1VSTCIsIlNQTEFUX1JBRElVUyIsIlNQTEFUX0ZPUkNFIiwiU0hBRElORyIsIkNPTE9SX1VQREFURV9TUEVFRCIsIkJBQ0tfQ09MT1IiLCJyIiwiZyIsImIiLCJUUkFOU1BBUkVOVCIsImNhbnZhc1JlZiIsImNhbnZhcyIsImN1cnJlbnQiLCJhbmltYXRpb25JZCIsImdsIiwicG9pbnRlcnMiLCJjb25maWciLCJQQVVTRUQiLCJpbml0V2ViR0wiLCJwYXJhbXMiLCJhbHBoYSIsImRlcHRoIiwic3RlbmNpbCIsImFudGlhbGlhcyIsInByZXNlcnZlRHJhd2luZ0J1ZmZlciIsImdldENvbnRleHQiLCJjb25zb2xlIiwid2FybiIsImNsZWFyQ29sb3IiLCJyZXNpemVDYW52YXMiLCJwaXhlbFJhdGlvIiwiTWF0aCIsIm1pbiIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJ3aWR0aCIsImZsb29yIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJjcmVhdGVQb2ludGVyIiwiaWQiLCJ0ZXhjb29yZFgiLCJ0ZXhjb29yZFkiLCJwcmV2VGV4Y29vcmRYIiwicHJldlRleGNvb3JkWSIsImRlbHRhWCIsImRlbHRhWSIsImRvd24iLCJtb3ZlZCIsImNvbG9yIiwiZ2VuZXJhdGVDb2xvciIsImNvbG9ycyIsInJhbmRvbSIsImxlbmd0aCIsInVwZGF0ZVBvaW50ZXIiLCJwb2ludGVyIiwieCIsInkiLCJhYnMiLCJjcmVhdGVTaW1wbGVGbHVpZCIsInZlcnRpY2VzIiwiRmxvYXQzMkFycmF5IiwiaW5kaWNlcyIsIlVpbnQxNkFycmF5IiwidmVydGV4QnVmZmVyIiwiY3JlYXRlQnVmZmVyIiwiYmluZEJ1ZmZlciIsIkFSUkFZX0JVRkZFUiIsImJ1ZmZlckRhdGEiLCJTVEFUSUNfRFJBVyIsImluZGV4QnVmZmVyIiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJ2ZXJ0ZXhTaGFkZXJTb3VyY2UiLCJmcmFnbWVudFNoYWRlclNvdXJjZSIsImNyZWF0ZVNoYWRlciIsInR5cGUiLCJzb3VyY2UiLCJzaGFkZXIiLCJzaGFkZXJTb3VyY2UiLCJjb21waWxlU2hhZGVyIiwiZ2V0U2hhZGVyUGFyYW1ldGVyIiwiQ09NUElMRV9TVEFUVVMiLCJlcnJvciIsImdldFNoYWRlckluZm9Mb2ciLCJkZWxldGVTaGFkZXIiLCJ2ZXJ0ZXhTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwiZnJhZ21lbnRTaGFkZXIiLCJGUkFHTUVOVF9TSEFERVIiLCJwcm9ncmFtIiwiY3JlYXRlUHJvZ3JhbSIsImF0dGFjaFNoYWRlciIsImxpbmtQcm9ncmFtIiwiZ2V0UHJvZ3JhbVBhcmFtZXRlciIsIkxJTktfU1RBVFVTIiwiZ2V0UHJvZ3JhbUluZm9Mb2ciLCJhdHRyaWJ1dGVzIiwicG9zaXRpb24iLCJnZXRBdHRyaWJMb2NhdGlvbiIsInVuaWZvcm1zIiwidGltZSIsImdldFVuaWZvcm1Mb2NhdGlvbiIsInJlc29sdXRpb24iLCJwb2ludGVyQ291bnQiLCJmbHVpZFByb2dyYW0iLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwicmVuZGVyIiwiY3VycmVudFRpbWUiLCJ2aWV3cG9ydCIsImNsZWFyIiwiQ09MT1JfQlVGRkVSX0JJVCIsInVzZVByb2dyYW0iLCJ1bmlmb3JtMWYiLCJ1bmlmb3JtMmYiLCJ1bmlmb3JtMWkiLCJwb2ludGVyUG9zaXRpb25zIiwicG9pbnRlckNvbG9ycyIsImkiLCJ1bmlmb3JtMmZ2IiwidW5pZm9ybTNmdiIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwidmVydGV4QXR0cmliUG9pbnRlciIsIkZMT0FUIiwiZHJhd0VsZW1lbnRzIiwiVFJJQU5HTEVTIiwiVU5TSUdORURfU0hPUlQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJoYW5kbGVNb3VzZU1vdmUiLCJlIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFgiLCJsZWZ0IiwiY2xpZW50WSIsInRvcCIsImhhbmRsZU1vdXNlRG93biIsImhhbmRsZU1vdXNlVXAiLCJoYW5kbGVUb3VjaFN0YXJ0IiwicHJldmVudERlZmF1bHQiLCJ0b3VjaCIsInRvdWNoZXMiLCJoYW5kbGVUb3VjaE1vdmUiLCJoYW5kbGVUb3VjaEVuZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiaGFuZGxlUmVzaXplIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVmIiwiY2xhc3NOYW1lIiwic3R5bGUiLCJ0b3VjaEFjdGlvbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/SplashCursor.tsx\n"));

/***/ })

});